<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>一种下载管理方案的设计与实现</title>
    <meta name="description" content="  前言| 导语4g时代流量资费大幅下降，各种“wbq”卡惊艳出世——在此背景下，下载对于移动端已不再是一种昂贵的高成本行为。同时emmc、ufs等存储介质的发展也为移动端下载解决了一定的i/o瓶颈问题。本文主要描述一种android端下载管理方案的设计和实现思路。重点在思路，实现方案并不一定十分完善^_^前言">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_8v3czwksspqlg14i.css">
    <link rel="stylesheet" href="/css/main.css ">
    <link rel="canonical" href="http://localhost:4000/2017/06/21/yi_zhong_xia_zai_guan_li_fang_an_de_she_ji_yu_shi_xian/">
    <link rel="alternate" type="application/rss+xml" title="MelonTeam" href="http://localhost:4000/feed.xml ">



</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">MelonTeam</a>
        <small>移动终端前沿技术的探索者</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/opensource/">
                        
                            <i class="fa fa-folder-open"></i>开源项目
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>归档
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>分类
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>标签
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/board/">
                        
                            <i class="fa fa-pencil"></i>留言板
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" post>
    <div class="left">
        <h1>一种下载管理方案的设计与实现</h1>
        <div class="label">

            <div class="label-card">
                <i class="fa fa-calendar"></i>2017-06-21
            </div>
            
            <div class="label-card">
                <i class="fa fa-user"></i>leoyxwang
            </div>
            
            
            
            <div class="label-card">
            




<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#android" title="Category: android" rel="category">android</a>
    
  

  <!-- <span class="point">•</span> -->
</span>



            </div>
            
            
            <div class="label-card">
            


<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <!--a href="/tag/#%E4%B8%8B%E8%BD%BD" title="Tag: 下载" rel="tag">下载</a-->
        <a href="/tag/#下载" title="Tag: 下载" rel="tag">下载</a>&nbsp;
    
        <!--a href="/tag/#%E4%BC%98%E5%85%88%E7%BA%A7" title="Tag: 优先级" rel="tag">优先级</a-->
        <a href="/tag/#优先级" title="Tag: 优先级" rel="tag">优先级</a>
    
  

</span>



            </div>
            

        </div>
        <hr>
        <article itemscope itemtype="http://schema.org/BlogPosting">
        <ul id="markdown-toc">
  <li><a href="#前言" id="markdown-toc-前言">前言</a></li>
  <li><a href="#一技术调研" id="markdown-toc-一技术调研">一、技术调研</a>    <ul>
      <li><a href="#11-downloadmanager" id="markdown-toc-11-downloadmanager">1.1 downloadmanager</a></li>
      <li><a href="#12-第三方开源下载组件" id="markdown-toc-12-第三方开源下载组件">1.2 第三方开源下载组件</a></li>
    </ul>
  </li>
  <li><a href="#二需求分析" id="markdown-toc-二需求分析">二、需求分析</a></li>
  <li><a href="#三详细设计" id="markdown-toc-三详细设计">三、详细设计</a>    <ul>
      <li><a href="#31-下载任务状态" id="markdown-toc-31-下载任务状态">3.1 下载任务状态</a></li>
      <li><a href="#32-下载任务控制" id="markdown-toc-32-下载任务控制">3.2 下载任务控制</a></li>
      <li><a href="#33-关键技术的实现" id="markdown-toc-33-关键技术的实现">3.3 关键技术的实现</a>        <ul>
          <li><a href="#331-任务队列" id="markdown-toc-331-任务队列">3.3.1 任务队列</a></li>
          <li><a href="#332-任务调度" id="markdown-toc-332-任务调度">3.3.2 任务调度</a></li>
          <li><a href="#333-任务线程模型dltaskdlthread" id="markdown-toc-333-任务线程模型dltaskdlthread">3.3.3 任务/线程模型（dltask/dlthread）</a></li>
          <li><a href="#334-数据表设计" id="markdown-toc-334-数据表设计">3.3.4 数据表设计</a></li>
          <li><a href="#335-消息通知" id="markdown-toc-335-消息通知">3.3.5 消息通知</a></li>
        </ul>
      </li>
      <li><a href="#34-设计总结" id="markdown-toc-34-设计总结">3.4 设计总结</a></li>
    </ul>
  </li>
  <li><a href="#四优化和总结" id="markdown-toc-四优化和总结">四、优化和总结</a></li>
</ul>

<p>| 导语
4g时代流量资费大幅下降，各种“wbq”卡惊艳出世——在此背景下，下载对于移动端已不再是一种昂贵的高成本行为。同时emmc、ufs等存储介质的发展也为移动端下载解决了一定的i/o瓶颈问题。本文主要描述一种android端下载管理方案的设计和实现思路。重点在思路，实现方案并不一定十分完善^_^</p>

<h1 id="前言">前言</h1>

<!--more-->
<p>观察几年前的移动应用可以发现，安装包体积非常小。原因很简单：呈现的内容简单，足够全量打包进安装包。如今业务繁杂、ui绚丽的需求由于安装包体积限制不可能再进行全量打包，必须通过后期的按需下载实现接入。因此，需要设计一个通用的下载组件管理app内所有资源的下载。</p>

<p><img src="/image/yi_zhong_xia_zai_guan_li_fang_an_de_she_ji_yu_shi_xian/8999e1db9ecda53d18b3e3c5268f31c9501f28853b1d308ce850e6fc267b4bff" alt="" /></p>

<h1 id="一技术调研">一、技术调研</h1>

<h2 id="11-downloadmanager">1.1 downloadmanager</h2>

<p>the download manager is a system service that handles long-running http
downloads. clients may request that a uri be downloaded to a particular
destination file. the download manager will conduct the download in the
background, taking care of http interactions and retrying downloads after
failures or across connectivity changes and system reboots. instances of this
class should be obtained through
<code class="highlighter-rouge">[getsystemservice(string)](https://developer.android.com/reference/android/content/context.html#getsystemservice\(java.lang.string\))</code>
by passing
<code class="highlighter-rouge">[download_service](https://developer.android.com/reference/android/content/context.html#download_service)</code>.
apps that request downloads through this api should register a broadcast
receiver for
<code class="highlighter-rouge">[action_notification_clicked](https://developer.android.com/reference/android/app/downloadmanager.html#action_notification_clicked)</code>
to appropriately handle when the user clicks on a running download in a
notification or from the downloads ui. note that the application must have the
<code class="highlighter-rouge">[internet](https://developer.android.com/reference/android/manifest.permission.html#internet)</code>
permission to use this class.</p>

<p>        从android 2.3（api level
9）开始，android以service的方式提供了全局的downloadmanager来系统级地优化处理长时间的下载操作。上述官方文档的描述中说明，downloadmanager支持失败重试、notification通知等基本特性。特别是系统组件的特性能够支持完全的后台下载。</p>

<p>        <strong>优点</strong></p>

<p>        （1）基于broadcast的通信机制实现与特定app零耦合。</p>

<p>        （2）对于简单的单文件下载，可以满足使用需求。</p>

<p>        （3）支持ipc。</p>

<p>        （4）对网络环境（移动网络、wi-fi等）进行了特殊处理，适合不同网络环境的使用。</p>

<p>        <strong>缺点</strong></p>

<p>        （1）需注册broadcast监听下载完成事件，稍显复杂。</p>

<p>        （2）基于contentprovider的任务查询机制，增加了使用复杂度。</p>

<p>        （3）需手动实现断点续传。</p>

<p>        （4）需手动实现单文件的多线程（分段）下载。</p>

<p>        （5）不支持下载任务的优先级调度。</p>

<h2 id="12-第三方开源下载组件">1.2 第三方开源下载组件</h2>

<p>github上存量的具有相对完整功能的下载组件并不多，较为突出的有<strong>filedownloader</strong>。支持在独立的下载进程进行下载保证健壮性，并支持替换网络请求框架。在项目中已有成熟应用。</p>

<p><img src="/image/yi_zhong_xia_zai_guan_li_fang_an_de_she_ji_yu_shi_xian/abe0034094aa4dc52e9c536022e2215fd0c76d188750532051ff6b8138214c9d" alt="" /></p>

<p>        优点</p>

<p>        （1）功能完整，可配置性高。</p>

<p>        （2）对实际应用场景做出了一定优化。如任务管理、掉帧处理等。</p>

<p>        缺点</p>

<p>        （1）组件代码量大，使用门槛稍高。</p>

<p><a href="https://github.com/lingochamp/filedownloader">https://github.com/lingochamp/filedownloader</a></p>

<h1 id="二需求分析">二、需求分析</h1>

<p>        经过相关方案的技术调研，可以简单的归纳出一个下载管理组件应该具有的功能：</p>

<p><strong>文件下载断点续传多线程多任务</strong><strong>优先级调度</strong></p>

<p>        本文结合上述技术方案的思想，本着简化优化的思想，设计一个下载管理的组件。功能需求如下。</p>

<p>        1）以任务为单位完成单个的文件下载</p>

<p>        2）对每个任务使用多线程分段下载（对大文件有效）</p>

<p>        3）支持任务断点续传</p>

<p>        4）支持多任务管理和优先级调度</p>

<p>        5）在数据库中保存所有未完成的任务信息</p>

<p>        6）实现完善的异常保护机制</p>

<p>        对用户来说，下载文件和配置下载管理是两个可直接交互的功能。下载文件包括：</p>

<p>        1）添加下载任务（手动开始）。</p>

<p>        2）开始下载任务（新建或断点续传）。</p>

<p>        3）停止下载任务（单线程任务相当于取消，多线程任务暂停）。</p>

<p>        4）取消下载任务（停止并删除）。</p>

<p>        5）查询任务信息（从内存或数据库中查询）。</p>

<p>        配置下载管理目前可设置最多同时下载的任务数，超出则进入排队队列。</p>

<p><img src="/image/yi_zhong_xia_zai_guan_li_fang_an_de_she_ji_yu_shi_xian/d223561039d0c68bc0023da1be99e5d40800f9def23c35fd6562207f144c2a98" alt="" /></p>

<h1 id="三详细设计">三、详细设计</h1>

<p>文件下载的主要功能是以任务为单位完整地完成一个文件的下载，包括下载任务配置、合法性验证、任务优先级和排队处理、线程数配置、下载控制、回调通知、异常处理和任务信息存储等一系列流程。</p>

<h2 id="31-下载任务状态">3.1 下载任务状态</h2>

<p><img src="/image/yi_zhong_xia_zai_guan_li_fang_an_de_she_ji_yu_shi_xian/b0b8566fc31c61ceab281d7f2c28ae7c3f0c1159fe568138f452778630f988f0" alt="" /></p>

<p>        下载的任务包括4种状态：就绪、下载中、排队中和已停止。<br />
（1）就绪（ready）。任务创建时默认为就绪状态，具有不可逆性，即不能从任何其他状态转化为就绪态。就绪态的任务未执行，已写入数据库。就绪任务可直接被取消（删除，下同）。<br />
（2）下载中（downloading）。任务在下载队列中正在下载，下载队列的大小由文件下载的最大任务数配置确定。若下载中的任务被优先级更高的任务插队，则转化为排队中状态。若下载中的任务被停止或产生异常（如网络中断），则转入已停止状态（数据库中同步任务信息）。任务下载完成后自动销毁（删除）。<br />
（3）排队中（queueing）。任务在排队队列中等待，直到下载队列中有任务被删除后根据排队队列中的优先级继续一个任务的下载。排队中的任务可被直接停止或取消。<br />
        （4）已停止（stopped）。任务执行过（可能经历过下载中或排队中状态），由于异常或被停止转入已停止状态。已停止的任务可被直接取消。</p>

<h2 id="32-下载任务控制">3.2 下载任务控制</h2>

<p>        下载管理组件需要对外开放部分api使外部能够对下载过程进行控制，主要包括新增任务、启动下载、停止下载和取消下载。<br />
        （1）新增任务（dladd）<br />
新增任务是指创建一个任务对象，设置下载url、保存路径（非必须，有默认值）、优先级、回调监听等必须的参数后把任务信息写入数据库进行持久化。此时任务未执行，各任务队列中还没有保存该任务。此api可用于添加一个手动执行的任务。<br />
        （2）启动下载（dlstart）<br />
        启动下载是一个比较复杂的过程，包括<strong>创建任务</strong>和<strong>加入任务队列</strong>两大过程。<br />
        <strong>创建任务</strong>首先检查任务参数合法性，然后检查该任务（url）是否为下载队列中的重复任务。接着处理历史任务恢复，先从内存中已停止队列查找url，再从数据库中查找url，恢复断点续传信息。最后完善任务信息、设置新的优先级、复位标志位后保存至数据库。<br />
        <strong>加入任务队列</strong>根据下载队列的大小和任务的优先级进行排队调度，决定将该任务加入排队队列或下载队列。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    /**
     * 开始一个下载任务
     *
     * @param url      文件下载地址
     * @param dir      文件下载后保存的目录地址，该值为空时会默认使用应用的文件缓存目录作为保存目录地址
     * @param name     文件名，文件名需要包括文件扩展名。该值可为空，为空时将由程序决定文件名。  
     * @param headers  请求头参数
     * @param priority 任务优先级
     * @param listener 下载监听器
     */
    public synchronized void dlstart(string url, string dir, string name, list headers, int priority,
                                     idlistener listener) {
        // 验证优先级合法
        if (priority != priority_low &amp;&amp; priority != priority_normal &amp;&amp; priority != priority_high &amp;&amp; priority !=
                priority_unspecified) {
            throw new illegalargumentexception("priority illegal. please set a correct priority between priority_low," +
                    " " +
                    "priority_normal, priority_high and priority_unspecified.");
        }
        boolean haslistener = listener != null;
        if (textutils.isempty(url)) {
            if (haslistener) {
                listener.onerror(error_invalid_url, "url can not be null.", url);
            }
            return;
        }
        if (!networkutil.isnetworkavailable(mcontext)) {
            if (haslistener) {
                listener.onerror(error_not_network, "network is not available.", url);
            }
            return;
        }
        // 是正在下载或排队的任务
        if (task_dling.containskey(url) || isqueueing(url)) {
            if (haslistener) {
                listener.onerror(error_repeat_url, "url is downloading.", url);
            }
            return;
        }
        // 不是正在下载或排队的任务
        logutil.logd(tag, "不是正在下载的任务");
        dltaskinfo info;
        // 是否是就绪任务或上次未执行过的排队任务
        boolean isreadytask = false;
        // 是运行/排队过的已暂停的任务
        if (task_stopped.containskey(url)) {
            logutil.logd(tag, "是运行/排队过的已暂停的任务，恢复下载.");
            info = task_stopped.remove(url);
        }
        // 内存任务列表中不存在该任务，从数据库中读取任务信息（本次运行未启动过该任务的下载）
        else {
            logutil.logd(tag, "不是运行过的已暂停任务，从数据库中恢复");
            info = dldbmanager.getinstance().querytaskinfo(url);
            if (null != info) {
                logutil.logd(tag, "数据库中查到信息");
                // directly add task case
                list threadinfo = dldbmanager.getinstance().queryallthreadinfo(url);
                if (threadinfo == null) {
                    logutil.logd(tag, "是就绪任务或上次未执行过的排队任务");
                    isreadytask = true;
                } else {
                    logutil.logd(tag, "是已暂停的任务");
                    info.threads.clear();
                    info.threads.addall(threadinfo);
                }
            }
        }
        // 新建任务
        if (!isreadytask &amp;&amp; null == info) {
            logutil.logd(tag, "新建任务");
            info = new dltaskinfo();
            info.baseurl = url;
            info.realurl = url;
            dir = textutils.isempty(dir) ? mcontext.getcachedir().getabsolutepath() : dir;
            info.dirpath = dir;
            info.filename = name;
        }
        // 断点续传任务（不是单线程任务）
        else if (!info.issinglethread) {
            logutil.logd(tag, "断点续传任务（不是单线程任务）");
            info.isresume = !isreadytask;
            for (dlthreadinfo threadinfo : info.threads) {
                threadinfo.isstop = false;
            }
        }
        info.redirect = 0;
        info.requestheaders = dlutil.initrequestheaders(headers, info);
        info.listener = listener;
        info.haslistener = haslistener;
        // 未指定优先级
        if (priority == priority_unspecified) {
            if (info.priority == priority_unspecified) {
                // 任务未指定优先级，使用中优先级
                info.priority = priority_normal;
            }
        }
        // 使用外部指定的优先级
        else {
            info.priority = priority;
        }
        // 任务插入数据库
        if (dldbmanager.getinstance().querytaskinfo(url) == null) {
            dldbmanager.getinstance().inserttaskinfo(info);
        }
        if (haslistener) {
            listener.oncreate(info);
        }
        resetqueue(info); // 强制isqueue复位
        // 检查当前下载任务数和优先级
        if (task_dling.size() &gt;= mmaxtask) {
            dltaskinfo lowestprioritydltask = task_dling_prio.get(task_dling_prio.size() - 1);
            logutil.logd(tag, "task_dling_prio中最低优先级为" + lowestprioritydltask.priority);
            logutil.logd(tag, "调用dlstart的任务优先级为" + info.priority);
            // 若当前下载队列中存在更低优先级的任务
            if (lowestprioritydltask.priority &gt; info.priority) {
                logutil.logd(tag, "当前下载队列中存在更低优先级的任务，正在下载队列中最低优先级任务进入排队");
                dlqueue(lowestprioritydltask.baseurl);
            }
            // 若当前下载队列中不存在更低优先级的任务
            else {
                logutil.logd(tag, "当前下载队列中不存在更低优先级的任务");
                addqueuetask(info);
                return;
            }
        }
        adddltaskpriority(info);
        task_dling.put(url, info);
        info.status = status_downloading;
        if (haslistener) {
            listener.onprepare(info.baseurl);
        }
        logutil.logd(tag, "准备运行任务url：" + url);
        pool_task.execute(new dltask(info));
    }
</code></pre>
</div>

<p>        （3）停止下载（dlstop）<br />
停止下载的操作对象是下载中或排队中的任务。首先处理内存中已停止队列和下载队列的添加和删除，然后通过标志位在下载线程中处理关闭网络连接、在数据库中保存任务信息、在内存中加入已停止队列和调度排队队列中的下一个任务。其中单线程（不支持多线程）任务的停止（暂停）等同于取消。</p>

<p><img src="/image/yi_zhong_xia_zai_guan_li_fang_an_de_she_ji_yu_shi_xian/aa3735bc91c363fa0720c58ab672ce23b64fd6a3c36571b8382c3b650e509dd0" alt="" /></p>

<p>        （4）取消下载（dlcancel）<br />
取消下载的操作对象是所有状态的任务。该方法需要特别区分已停止任务和就绪任务。下载中的任务从下载队列中删除后，在下载线程中关闭网络连接、清理数据（删除数据库信息和已下载文件）、调度下一个排队任务。对于排队中的任务，从排队队列中删除后，清理数据即可。已停止任务需从已停止队列中删除任务。而就绪任务不在内存的任务队列中，只需清理数据。</p>

<p><img src="/image/yi_zhong_xia_zai_guan_li_fang_an_de_she_ji_yu_shi_xian/65d87fcda292f3c8c79261c321811570593671f391d29e8f262593b1fb036810" alt="" /></p>

<h2 id="33-关键技术的实现">3.3 关键技术的实现</h2>

<h3 id="331-任务队列">3.3.1 任务队列</h3>

<p>        下载管理一共包含4个支持线程并发的任务队列。<br />
        1）下载队列（<strong>concurrenthashmap</strong>）。用于保存正在下载的任务信息（dltaskinfo）。<br />
2）下载优先级队列（<strong>synchronizedlist</strong>）。考虑到concurrenthashmap插入entry的无序性，故设置一个保存正在下载任务优先级的队列用于快速查找。<br />
        3）已停止队列（<strong>concurrenthashmap</strong>）。用于保存执行过的已停止任务信息。<br />
        4）排队队列（**synchronizedlist
**）。用于保存排队中的任务信息，按任务优先级从高到底排列，高优先级任务位于队首，便于取出。</p>

<h3 id="332-任务调度">3.3.2 任务调度</h3>

<p>任务调度以任务的优先级为依据。优先级越高，优先级的正值越小。对未指定优先级的处理在启动下载的dlstart方法中的“设置任务优先级”部分，设计此项可为多次执行的下载任务改变优先级。</p>

<p>优先级(int)</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>说明</p>

<p>—|—</p>

<p>prio_low(3)</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>文件下载任务低优先级（默认）</p>

<p>prio_normal(2)</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>文件下载任务中优先级</p>

<p>prio_high(1)</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>文件下载任务高优先级</p>

<p>prio_unspecified(0)</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>使用原有优先级，未指定时使用默认低优先级</p>

<p>下载队列中保存的任务数是有上限的，超出上限的任务需保存至排队队列中。因此，当有任务结束（完成/停止/取消）时需要通过任务调度执行排队队列中的其他任务。基于优先级的任务调度从排队队列中取出第一个排队任务（优先级最高），加入下载队列开始下载。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    /**
     * 调度排队任务
     *
     * @return
     */
    synchronized dlmanager scheduledltask() {
        if (!task_queue.isempty()) {
            if (task_dling.size() &gt;= mmaxtask) {
                logutil.logd(tag, "task_dling_prio中最低优先级为" + task_dling_prio.get(task_dling_prio.size() - 1).priority);
                logutil.logd(tag, "task_prepare中最高优先级为" + task_queue.get(0).priority);
                if (task_dling_prio.get(task_dling_prio.size() - 1).priority &lt; task_queue.get(0).priority) {
                    logutil.logd(tag, "排序队列中没有可替换调度的任务");
                }
            } else {
                dltaskinfo info = poppreparetask();
                adddltaskpriority(info);
                task_dling.put(info.baseurl, info);
                info.status = status_downloading;
                if (info.haslistener) {
                    info.listener.onprepare(info.baseurl);
                }
                pool_task.execute(new dltask(info));
            }
        }
        return smanager;
    }
</code></pre>
</div>

<h3 id="333-任务线程模型dltaskdlthread">3.3.3 任务/线程模型（dltask/dlthread）</h3>

<p>由于一些原因，本下载组件设计之初加入了单文件多线程分段下载的支持（实际上移动端通常采用的做法是单文件单线程，因为这样足够用），增强了一定的健壮性。</p>

<p><img src="/image/yi_zhong_xia_zai_guan_li_fang_an_de_she_ji_yu_shi_xian/d2855b1d9e8f863efededcd70b975267bb738961d4eb01256010b516818dd6ed" alt="" /></p>

<p>文件下载初始化时创建了线程池<strong>pool_task</strong>负责执行下载任务和线程池<strong>pool_thread</strong>负责执行下载线程，线程池大小和阻塞队列长度根据设备运行时的cpu核心数确定。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    private final executorservice pool_task = new threadpoolexecutor(pool_size,
            pool_size_max, 3, timeunit.seconds, pool_queue_task, task_factory);
    private final executorservice pool_thread = new threadpoolexecutor(pool_size * 5,
            pool_size_max * 5, 1, timeunit.seconds, pool_queue_thread, thread_factory);
</code></pre>
</div>

<p>        启动下载后，线程池<strong>pool_task</strong>开始执行下载任务：<br />
1）使用<strong>httpurlconnection</strong>建立网络连接获取响应码和头信息（文件长度、文件名等），确定是否使用多线程（响应码为200或响应码为206且文件长度为0时使用单线程，<strong><em>注：此处可能有别的判断方法，需根据服务器的实际情况判断</em></strong>）。<br />
        2）校验本地文件（包括临时文件）是否存在和完整，决定是否继续下载。可根据md5进行文件完整性校验。<br />
        3）初始化和同步数据库中的任务信息和线程信息。历史任务直接恢复线程信息。如使用多线程，线程数根据每个线程最大长度的配置值计算得出。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    /**
     * 设置线程信息
     */
    private void dldispatch() {
        int threadsize;
        int threadlength;
        // 线程数下限: 小于length_per_thread开单线程
        if (info.totalbytes &lt;= length_per_thread) {
            threadsize = 1;
        }
        // 线程数上限: 大于length_per_thread * 2开2个线程
        else if (info.totalbytes &gt; length_per_thread * 2) {
            threadsize = 2;
        }
        // 根据文件大小分配线程
        else {
            threadsize = info.totalbytes / length_per_thread;
        }
        threadlength = info.totalbytes / threadsize;
        int remainder = info.totalbytes % threadlength;
        logutil.logd(tag, "thread calc finished:" + info.baseurl + ", threadsize=" + threadsize);
        for (int i = 0; i &lt; threadsize; i++) {
            int start = i * threadlength;
            int end = start + threadlength - 1;
            if (i == threadsize - 1) {
                end = start + threadlength + remainder;
            }
            dlthreadinfo threadinfo =
                    new dlthreadinfo(uuid.randomuuid().tostring(), info.baseurl, start, end);
            info.adddlthread(threadinfo);
            dldbmanager.getinstance().insertthreadinfo(threadinfo);
            dlmanager.getinstance().adddlthread(new dlthread(threadinfo, info, this));
            logutil.logd(tag, "not resume task thread added:" + info.baseurl);
        }
    }
</code></pre>
</div>

<p>        线程初始化完成后，线程池<strong>pool_thread</strong>开始执行下载线程：<br />
        1）设置请求头的range参数为线程的起始位置和结束位置，使用<strong>httpurlconnection</strong>用get方式建立网络连接。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    /**
     * 添加请求头参数
     *
     * @param conn
     */
    private void addrequestheaders(httpurlconnection conn) {
        for (dlheader header : dlinfo.requestheaders) {
            conn.addrequestproperty(header.key, header.value);
        }
        conn.setrequestproperty("range", "bytes=" + dlthreadinfo.start + "-" + dlthreadinfo.end);
    }
</code></pre>
</div>

<p>        2）根据线程的起始和结束位置使用<strong>randomaccessfile</strong>实现文件的随机读写。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>            raf = new randomaccessfile(dlinfo.file, "rw");
            fd = raf.getfd();
            // 定位到开始写文件位置
            raf.seek(dlthreadinfo.start);

            byte[] b = new byte[raf_buffer_size];
            int len;
            while (!dlthreadinfo.isstop &amp;&amp; !dlthreadinfo.iscancel &amp;&amp; !dlthreadinfo.isqueue &amp;&amp; !dlinfo.isqueue &amp;&amp; (len
                    = bis.read(b)) != -1) {
                dlthreadinfo.start += len;
                raf.write(b, 0, len);
                listener.onprogress(len, fd, dlthreadinfo);
            }
</code></pre>
</div>

<p>3）下载进度回调（onprogress）在下载过程中不断被调用，完成文件写入和进度保存（内存和数据库）。结合最短间隔和最小已下载文件长度增量控制回调频率，防止ui刷新过快（掉帧处理）。并配合
<strong>filedescriptor</strong>实现延迟写入存储设备，解决randomaccessfile无缓冲的问题，最大程度地提升下载效率。<strong><em>注：此处也可采用nio方式解决randomaccessfile无缓冲的问题。</em></strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>   @override
    public synchronized void onprogress(int progress, filedescriptor fd, dlthreadinfo threadinfo) {
        info.currentbytes += progress;
        logutil.logd(tag, info.currentbytes + "");

        long timenow = systemclock.elapsedrealtime();
        long timedelta = timenow - lasttime;
        int bytesdelta = info.currentbytes - lasttotalbytes;

        if (timedelta &gt; min_progress_interval &amp;&amp; bytesdelta &gt; min_progress_step) {
            // 同步文件
            if (fd != null) {
                try {
                    fd.sync();
                } catch (syncfailedexception e) {
                    e.printstacktrace();
                }
            }
            // 更新数据库
            if (threadinfo != null) {
                dldbmanager.getinstance().updatethreadinfo(threadinfo);
                dldbmanager.getinstance().updatetaskinfo(info);
            }
            // 保存本次进度
            lasttime = timenow;
            lasttotalbytes = info.currentbytes;
            // 通知ui
            if (info.haslistener) {
                info.listener.onprogress(info.currentbytes, info.totalbytes, info.baseurl);
            }
        }
    }
</code></pre>
</div>

<p>        4）下载完成回调（onfinish）在下载完成时被调用，删除下载任务和数据库中的任务信息后进行任务调度。</p>

<h3 id="334-数据表设计">3.3.4 数据表设计</h3>

<p>文件下载需要在下载过程中对下载任务和下载线程信息进行持久化，以保证文件下载线程或app被结束后能够实现断点续传，减少重复的下载量。与<strong>downloadmanager</strong>思路相同，但只使用数据库存储供app内部使用。<br />
两张表以baseurl建立关联。线程表只保存本线程的起始位置和结束位置，uuid方便线程完成后删除线程。任务表保存除线程表中以外的所有任务相关信息。</p>

<p>下载任务数据表</p>

<p><strong>字段</strong><em>**</em></p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p><strong>类型</strong><em>**</em></p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p><strong>说明</strong><em>**</em></p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p><strong>约束</strong><em>**</em></p>

<p>—|—|—|—</p>

<p>_id</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>integer</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>唯一标识符</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>自增主键，不可为空</p>

<p>baseurl</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>varchar(255)</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>文件原始url</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>不可为空</p>

<p>realurl</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>varchar(255)</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>文件真实url</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>不可为空</p>

<p>dirpath</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>varchar(127)</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>文件保存路径</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>不可为空</p>

<p>filename</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>varchar(30)</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>文件保存名称</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>不可为空</p>

<p>currentbytes</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>integer</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>文件已下载大小</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>非负</p>

<p>totalbytes</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>integer</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>文件总大小</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>非负</p>

<p>priority</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>integer</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>任务优先级</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>无</p>

<p>下载线程数据表</p>

<p><strong>字段</strong><em>**</em></p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p><strong>类型</strong><em>**</em></p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p><strong>说明</strong><em>**</em></p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p><strong>约束</strong><em>**</em></p>

<p>—|—|—|—</p>

<p>_id</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>integer</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>唯一标识符</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>自增主键，不可为空</p>

<p>baseurl</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>varchar(255)</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>文件原始url</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>外键，不可为空</p>

<p>id</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>varchar(127)</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>线程uuid，唯一标识线程</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>不可为空</p>

<p>startpos</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>integer</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>线程开始下载位置（bytes）</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>非负</p>

<p>endpos</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>integer</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>线程结束下载位置（bytes）</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>非负</p>

<h3 id="335-消息通知">3.3.5 消息通知</h3>

<p>文件下载内部的任务/线程模型基本上是异步操作，因此需要通过回调实现相互通知。外部调用者也需要知道下载执行的过程，因此提供了两种消息通知机制，即回调和事件总线。</p>

<p><img src="/image/yi_zhong_xia_zai_guan_li_fang_an_de_she_ji_yu_shi_xian/38c0ffce784a2d5ddaea60640110de13becaff1d4d94a69072d6d2bccbef5117" alt="" /></p>

<p>上图描述了线程（<strong>dlthread</strong>）通知任务（<strong>dltask</strong>）的流程。外部改变线程中不同状态的标记位结束线程的下载过程，线程通过线程监听（<strong>idlthreadlistener</strong>）的onxxx的回调方法通知任务进行处理。<br />
最重要的是对外部调用者的消息通知。和内部通知类似，文件下载提供了一种任务监听（<strong>idlistener</strong>），包含了9种回调方法，如下表所示。</p>

<p><strong>方法名</strong><em>**</em></p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p><strong>参数</strong><em>**</em></p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p><strong>调用时机</strong><em>**</em></p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p><strong>调用线程</strong><em>**</em></p>

<p>—|—|—|—</p>

<p>oncreate</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>dltaskinfo</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>任务创建完成并入库</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>主线程</p>

<p>onprepare</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>baseurl</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>任务入队，即将开始下载</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>主/后台线程</p>

<p>onerror</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>status, msg, baseurl</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>产生异常情况</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>主/后台线程</p>

<p>onstart</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>filename, baseurl, filelength</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>任务初始化完成</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>后台线程</p>

<p>onprogress</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>progress, totalbytes, baseurl</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>下载进度更新</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>后台线程</p>

<p>onstop</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>progress, baseurl</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>停止下载任务</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>主/后台线程</p>

<p>onfinish</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>file, baseurl</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>任务下载完成</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>主/后台线程</p>

<p>oncancel</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>baseurl</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>取消下载任务</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>主/后台线程</p>

<p>onqueue</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>baseurl</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>任务进入排队</p>

<table>
  <tbody>
    <tr>
    </tr>
  </tbody>
</table>

<p>主/后台线程</p>

<p>从表中注意到不同回调方法的调用线程不同。为方便使用，提供了两种回调监听实现类。一种是<strong>simpledlistener</strong>，默认所有回调方法的实现为空，通知方和接收方一对一耦合；另一种为<strong>eventbusdlistener</strong>，每个回调方法的实现类均为发送<strong>eventbus</strong>事件，方便事件接收方完成线程切换和全局监听。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>/**
 * 使用eventbus的download listener
 */
public class eventbusdllistener implements idlistener {

    @override
    public void oncreate(dltaskinfo info) {
        eventbus.getdefault().post(new dlcreateevent(info));
    }

    @override
    public void onprepare(string baseurl) {
        eventbus.getdefault().post(new dlprepareevent(baseurl));
    }


    @override
    public void onstart(string filename, string baseurl, int filelength) {
        eventbus.getdefault().post(new dlstartevent(filename, baseurl, filelength));
    }


    @override
    public void onprogress(int progress, int total, string baseurl) {
        eventbus.getdefault().post(new dlprogressevent(progress, total, baseurl));
    }


    @override
    public void onstop(int progress, string baseurl) {
        eventbus.getdefault().post(new dlstopevent(progress, baseurl));
    }


    @override
    public void onfinish(file file, string baseurl) {
        eventbus.getdefault().post(new dlfinishevent(file, baseurl));
    }


    @override
    public void onerror(int status, string error, string baseurl) {
        eventbus.getdefault().post(new dlerrorevent(status, error, baseurl));
    }


    @override
    public void oncancel(string baseurl) {
        eventbus.getdefault().post(new dlcancelevent(baseurl));
    }


    @override
    public void onqueue(string baseurl) {
        eventbus.getdefault().post(new dlqueueevent(baseurl));
    }
}
</code></pre>
</div>

<h2 id="34-设计总结">3.4 设计总结</h2>

<p>        下载管理主要类图如下。</p>

<p><img src="/image/yi_zhong_xia_zai_guan_li_fang_an_de_she_ji_yu_shi_xian/e2ee46cab3de2a96e58d0ecf343e868ebbd40d1bdca95090135827c98e311fae" alt="" /></p>

<p>        <strong>dlmanager</strong>负责与外部的交互和下载过程的控制。<strong>dldbmanager</strong>负责数据库的读写。<strong>dltask</strong>和<strong>dlthread</strong>负责完成下载逻辑，其中<strong>dltaskinfo</strong>和<strong>dlthreadinfo</strong>分别为任务和线程信息的实体类，<strong>idlthreadlistener</strong>负责线程和任务间的通信。<strong>idlistener</strong>以及它的两个实现类负责文件下载与外部的通信。</p>

<h1 id="四优化和总结">四、优化和总结</h1>

<p>        针对部分低端机型下载过程中可能遇到的下载速度偏低、系统响应迟钝的情况，做了一定的优化。<br />
1）对<strong>dltask</strong>和<strong>dlthread</strong>等后台线程，降低线程优先级。调用代码process.setthreadpriority(process.thread_priority_background)即可。<br />
2）对<strong>httpurlconnection</strong>使用<strong>bufferedinputstream</strong>包装输入流，并将读取数据的缓冲区适当增大为8kb（8*1024），减少存储设备i/o次数。<br />
        结合上文叙述的<strong>掉帧处理</strong>，优化后卡顿现象明显改善，下载速度能够达到最大带宽。</p>

<hr />

<p>另外，本文描述的下载管理方案可能存在如主进程下载的不稳定性、不支持跨进程通信等一些问题，实际应用中仍需做进一步的改进。但总体思路仍具有一定的参考意义。</p>

<p>        thanks~~~</p>


        </article>
        <hr>

        
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
        

        <div class="post-recent">
    <div class="pre">
        
        <p><strong>上一篇</strong> <a href="/2017/06/21/iphone_she_ying_zhong_de_shen_du_bu_zhuo_wwdc2017_session_507_/">iphone摄影中的深度捕捉(wwdc2017-session 507)</a></p>
        
    </div>
    <div class="nex">

        
        <p><strong>下一篇</strong> <a href="/2017/06/24/wwdc2017_xiao_jie/">wwdc2017小结</a></p>
        
    </div>
</div>


        <h2 id="comments">说一说</h2>
        

<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript">
var uyan_config = {
     'url':'http://localhost:4000/2017/06/21/yi_zhong_xia_zai_guan_li_fang_an_de_she_ji_yu_shi_xian/',
     'du':'http://localhost:4000', 
     'su':'http://localhost:4000/2017/06/21/yi_zhong_xia_zai_guan_li_fang_an_de_she_ji_yu_shi_xian/' 
};
</script>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2136610"></script>
<!-- UY END -->






    </div>
    <button class="anchor"><i class="fa fa-anchor"></i></button>
    <div class="right">
        <div class="wrap">

            <!-- Content -->
            <div class="side content">
                <div>
                    目录
                </div>
                <ul id="content-side" class="content-ul">
                    
                    <li><a href="#comments">说一说</a></li>
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <!-- <div class="side">bbbb</div> -->
        </div>
    </div>
</div>
<script>
/**
 * target _blank
 */
(function() {
    var aTags = document.querySelectorAll('article a:not([id])')
    for (var i = 0; i < aTags.length; i++) {
        aTags[i].setAttribute('target', '_blank')
    }
}());
</script>
<script src="/js/pageContent.js " charset="utf-8"></script>


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
            
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/MelonTeam" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>         
            
        </p>
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>


<script type="text/javascript" src="http://tajs.qq.com/stats?sId=62569168" charset="UTF-8"></script>


    <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/smooth-scroll.min.js " charset="utf-8"></script>
    <script type="text/javascript">
      smoothScroll.init({
        speed: 500, // Integer. How fast to complete the scroll in milliseconds
        easing: 'easeInOutCubic', // Easing pattern to use
        offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
      });
    </script>
    <!-- <script src=" /js/scroll.min.js " charset="utf-8"></script> -->
  </body>

</html>
