<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>一个创建自定义事件源的例子</title>
    <meta name="description" content="  runloop 的适用场景上一篇文章我们介绍了runloop的相关知识，但是毕竟我们实际开发中很少应用，今天我们就通过介绍runloop在ios系统中的应用，来实现一个小小的demo，启发我们在开发过程中设计代码架构时的思路。runloop 的适用场景">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_8v3czwksspqlg14i.css">
    <link rel="stylesheet" href="/css/main.css ">
    <link rel="canonical" href="http://localhost:4000/2017/06/01/yi_ge_chuang_jian_zi_ding_yi_shi_jian_yuan_de_li_zi/">
    <link rel="alternate" type="application/rss+xml" title="MelonTeam" href="http://localhost:4000/feed.xml ">



</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">MelonTeam</a>
        <small>移动终端前沿技术的探索者</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/opensource/">
                        
                            <i class="fa fa-folder-open"></i>开源项目
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>归档
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>分类
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>标签
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/board/">
                        
                            <i class="fa fa-pencil"></i>留言板
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" post>
    <div class="left">
        <h1>一个创建自定义事件源的例子</h1>
        <div class="label">

            <div class="label-card">
                <i class="fa fa-calendar"></i>2017-06-01
            </div>
            
            <div class="label-card">
                <i class="fa fa-user"></i>justinytang
            </div>
            
            
            
            <div class="label-card">
            




<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#ios" title="Category: ios" rel="category">ios</a>
    
  

  <!-- <span class="point">•</span> -->
</span>



            </div>
            
            
            <div class="label-card">
            


<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <!--a href="/tag/#%E7%BA%BF%E7%A8%8B" title="Tag: 线程" rel="tag">线程</a-->
        <a href="/tag/#线程" title="Tag: 线程" rel="tag">线程</a>&nbsp;
    
        <!--a href="/tag/#runloop" title="Tag: runloop" rel="tag">runloop</a-->
        <a href="/tag/#runloop" title="Tag: runloop" rel="tag">runloop</a>
    
  

</span>



            </div>
            

        </div>
        <hr>
        <article itemscope itemtype="http://schema.org/BlogPosting">
        <ul id="markdown-toc">
  <li><a href="#runloop-的适用场景" id="markdown-toc-runloop-的适用场景"><strong>runloop 的适用场景</strong></a></li>
  <li><a href="#runloop-的使用" id="markdown-toc-runloop-的使用"><strong>runloop 的使用</strong></a>    <ul>
      <li><a href="#获取runloop-对象" id="markdown-toc-获取runloop-对象"><strong>获取 runloop 对象</strong></a></li>
      <li><a href="#配置运行循环" id="markdown-toc-配置运行循环"><strong>配置运行循环</strong></a></li>
      <li><a href="#启动运行循环" id="markdown-toc-启动运行循环"><strong>启动运行循环</strong></a></li>
      <li><a href="#退出运行循环" id="markdown-toc-退出运行循环"><strong>退出运行循环</strong></a></li>
    </ul>
  </li>
  <li><a href="#runloop-在ios中的应用" id="markdown-toc-runloop-在ios中的应用">runloop 在ios中的应用</a>    <ul>
      <li><a href="#autoreleasepool" id="markdown-toc-autoreleasepool">autoreleasepool</a></li>
      <li><a href="#事件响应" id="markdown-toc-事件响应">事件响应</a></li>
      <li><a href="#手势识别" id="markdown-toc-手势识别">手势识别</a></li>
      <li><a href="#界面更新" id="markdown-toc-界面更新">界面更新</a></li>
      <li><a href="#网络请求" id="markdown-toc-网络请求">网络请求</a></li>
    </ul>
  </li>
  <li><a href="#一个demo" id="markdown-toc-一个demo">一个demo</a>    <ul>
      <li><a href="#第一步创建任务线程" id="markdown-toc-第一步创建任务线程">第一步：创建任务线程</a></li>
      <li><a href="#第二步设计自定义事件源" id="markdown-toc-第二步设计自定义事件源">第二步：设计自定义事件源</a></li>
      <li><a href="#第三步设计触发事件源的函数" id="markdown-toc-第三步设计触发事件源的函数">第三步：设计触发事件源的函数</a></li>
      <li><a href="#第四步退出子线程runloop" id="markdown-toc-第四步退出子线程runloop">第四步：退出子线程runloop</a></li>
    </ul>
  </li>
</ul>

<p>上一篇文章我们介绍了runloop的相关知识，但是毕竟我们实际开发中很少应用，今天我们就通过介绍runloop在ios系统中的应用，来实现一个小小的demo，启发我们在开发过程中设计代码架构时的思路。</p>

<h2 id="runloop-的适用场景"><strong>runloop 的适用场景</strong></h2>
<!--more-->

<p>       回顾一下上一篇文章的介绍，只有当你为你的应用创建子线程时，才可能需要显式的运行一个 runloop 。而主线程的 runloop
是自动启动循环。对于子线程，当线程有更多交互的情况。例如：</p>

<ul>
  <li>使用端口或自定义输入源来与其他线程通信。</li>
  <li>在线程上使用计时器。</li>
  <li>在程序中使用任何performselector方法。</li>
  <li>使线程执行周期任务</li>
</ul>

<p>则你需要启动一个 runloop 。</p>

<h2 id="runloop-的使用"><strong>runloop 的使用</strong></h2>

<p>        runloop 对象为主要界面提供添加输入源、计时器和 runloop 观察者到你的 runloop 并运行之。每个线程都有一个单独的
runloop 对象与之相关联。在cocoa，这个对象是 nsrunloop 类的一个实例。在底层应用中，它是一个指向 cfrunloopref
不透明类型的指针。</p>

<h3 id="获取runloop-对象"><strong>获取 runloop 对象</strong></h3>

<p>        为了获取当前线程的 runloop ，你可以使用下列方法之一：</p>

<ul>
  <li>使用 nsrunloop 的 currentrunloop 类方法来获取一个 nsrunloop 对象。</li>
  <li>使用 cfrunloopgetcurrent 函数。</li>
</ul>

<p>        当需要时，你可以从 nsrunloop 对象获取一个 cfrunloopref 不透明类型指针。nsrunloop 类定义了一个
getcfrunloop 方法，返回一个 cfrunloopref 类型，你可以传递到核心基础程序。因为两个对象引用相同 nsrunloop
，如果需要你可以混合调用 nsrunloop 对象和 cfrunloopref 不透明类型。</p>

<h3 id="配置运行循环"><strong>配置运行循环</strong></h3>

<p>        在子线程运行一个 runloop 之前，你必须添加至少一个输入源或计时器到 runloop 上。如果一个 runloop
没有任何来源要监控，当你试图运行它时，它会立即退出。</p>

<p>        除了增加来源，你可以增加 runloop 观察者并使用它们来监测 runloop 的不同执行阶段。为了增加一个 runloop
观察者，创建一个 cfrunloopobserverref 不透明类型并使用 cfrunloopaddobserver 函数来添加到你的 runloop
上。</p>

<p>        下面的代码向你展示如何创建 runloop 观察者，因此代码简单的设置了一个 runloop 来监视所有 runloop 活动。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)threadmain
{
    // the application uses garbage collection, so no autorelease pool is needed.
    nsrunloop* myrunloop = [nsrunloop currentrunloop];
    // create a run loop observer and attach it to the run loop.
    cfrunloopobservercontext  context = {0, self, null, null, null};
    cfrunloopobserverref    observer = cfrunloopobservercreate(kcfallocatordefault,
            kcfrunloopallactivities, yes, 0, &amp;myrunloopobserver, &amp;context);
    if (observer)
    {
        cfrunloopref    cfloop = [myrunloop getcfrunloop];
        cfrunloopaddobserver(cfloop, observer, kcfrunloopdefaultmode);
    }
    // create and schedule the timer.
    [nstimer scheduledtimerwithtimeinterval:0.1 target:self
                selector:@selector(dofiretimer:) userinfo:nil repeats:yes];
    nsinteger    loopcount = 10;
    do
    {
        // run the run loop 10 times to let the timer fire.
        [myrunloop rununtildate:[nsdate datewithtimeintervalsincenow:1]];
        loopcount--;
    }
    while (loopcount);
}
</code></pre>
</div>

<p>        当为一个长期线程配置 runloop ，最好添加至少一个输入源来接收消息。尽管你可以仅添加一个计时器来进入 runloop
，一旦计时器触发后，它通常是无效的，这将导致 runloop 退出。附加一个重复的计时器可以保持 runloop
运行一段较长的时间，但会涉及到周期性的触发计时器唤醒你的线程，这实际上是另一种形式的轮询。相比之下，一个输入源等待事件发生，保持你的线程休眠直到它完成。</p>

<h3 id="启动运行循环"><strong>启动运行循环</strong></h3>

<p>        只有子线程才需要启动 runloop 。一个 runloop 必须至少有一个输入源或计时器用于监控。如果没有，运行循环将立即退出。</p>

<p>        有以下几种方法来启动 runloop ：</p>

<ul>
  <li>无条件的：</li>
</ul>

<p>        无条件的进入你的 runloop 是最简单的选择，但也是最不可取的。无条件的运行你的 runloop 将线程放置到一个永久循环，你对
runloop 本身只有很少的控制。你可以添加和删除输入源和计时器，但停止 runloop 的唯一方法是杀死它。也没办法在自定义模式下运行 runloop
。</p>

<ul>
  <li>设置时间限制：</li>
</ul>

<p>        相比无条件的运行一个 runloop ，运行一个有超时值的 runloop 是更好的。当你使用一个超时值时，runloop
持续运行直到一个事件到达或者分配的时间过期。如果一个事件到达，该事件被分配到一个处理程序来处理，runloop 退出。你的代码可以重新启动 runloop
来处理下一个事件。如果分配的时间过期，你可以简单的重启 runloop。</p>

<ul>
  <li>在一个特定的模式：</li>
</ul>

<p>        除了设置超时时间，你也可以使用特定模式来运行你的 runloop 。模式和超时时间并不互斥，在启动 runloop 时都可以使用。</p>

<p>        下面一段代码展示了子线程主入口该怎么设计。这个例子的关键部分展示了 runloop 的基本结构。从本质上说，你添加输入源和计时器到
runloop ，然后反复调用程序来启动 runloop 。每次 runloop 程序返回，检查是否出现任何条件批准线程退出。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)skeletonthreadmain
{
    // set up an autorelease pool here if not using garbage collection.
    bool done = no;
    // add your sources or timers to the run loop and do any other setup.
    do
    {
        // start the run loop but return after each source is handled.
        sint32    result = cfrunloopruninmode(kcfrunloopdefaultmode, 10, yes);
        // if a source explicitly stopped the run loop, or if there are no
        // sources or timers, go ahead and exit.
        if ((result == kcfrunlooprunstopped) || (result == kcfrunlooprunfinished))
            done = yes;
        // check for any other exit conditions here and set the
        // done variable as needed.
    }
    while (!done);
    // clean up code here. be sure to release any allocated autorelease pools.
}
</code></pre>
</div>

<p>        可以递归的运行一个 runloop 。换句话说，你可以调用 cfrunlooprun, cfrunloopruninmode 或任何
nsrunloop 方法来启动 runloop ，但其中必须有输入源或计时器的处理模块。当这样做时，你可以使用任何你想要的方式来运行嵌套的 runloop
，包括在 runloop 外使用的模式。</p>

<h3 id="退出运行循环"><strong>退出运行循环</strong></h3>

<p>        有两种方法可以使 runloop 在处理事件前退出：</p>

<ul>
  <li>配置 runloop 一个超时值：</li>
</ul>

<p>        使用一个超时值当然是首选，如果你可以管理它。指定一个超时值，让 runloop 完成所有正常进程，包括在退出前通知 runloop 观察者。</p>

<ul>
  <li>告知 runloop 停止：</li>
</ul>

<p>        显式的使用 cfrunloopstop 函数停止 runloop 产生的结果类似于超时。 runloop 发送任何剩余 runloop
通知然后退出。不同的是你可以在无条件启动 runloop 时使用此方法。</p>

<p>        注意：尽管删除 runloop 的输入源和计时器也可能导致 runloop 退出，但这并不是常规的方式。某些时候一些系统程序会注入输入源到
runloop 来处理事件，你无法了解到是否有系统添加的输入源，这将阻止 runloop 退出。</p>

<h2 id="runloop-在ios中的应用">runloop 在ios中的应用</h2>

<h3 id="autoreleasepool">autoreleasepool</h3>

<p>     app启动后，苹果在主线程 runloop 里注册了两个 observer，其回调都是
_wraprunloopwithautoreleasepoolhandler()。</p>

<p>     第一个 observer 监视的事件是 entry(即将进入loop)，其回调内会调用 _objc_autoreleasepoolpush()
创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>

<p>     第二个 observer 监视了两个事件： beforewaiting(准备进入休眠) 时调用_objc_autoreleasepoolpop()
和 _objc_autoreleasepoolpush() 释放旧的池并创建新池；exit(即将退出loop) 时调用
_objc_autoreleasepoolpop() 来释放自动释放池。这个 observer 的 order 是
2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>

<p>     在主线程执行的代码，通常是写在诸如事件回调、timer回调内的。这些回调会被 runloop 创建好的 autoreleasepool
环绕着，所以不会出现内存泄漏，开发者也不必显示创建 pool 了。</p>

<h3 id="事件响应">事件响应</h3>

<p>    苹果注册了一个 source1 (基于 mach port 的) 用来接收系统事件，其回调函数为
__iohideventsystemclientqueuecallback()。</p>

<p>    当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 iokit.framework 生成一个 iohidevent 事件并由 springboard
接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/iohidfamily">这里</a>。springboard
只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 event，随后用 mach port 转发给需要的app进程。随后苹果注册的那个 source1
就会触发回调，并调用 _uiapplicationhandleeventqueue() 进行应用内部的分发。</p>

<p>     _uiapplicationhandleeventqueue() 会把 iohidevent 处理并包装成 uievent
进行处理或分发，其中包括识别 uigesture/处理屏幕旋转/发送给 uiwindow 等。通常事件比如 uibutton
点击、touchesbegin/move/end/cancel 事件都是在这个回调中完成的。</p>

<h3 id="手势识别">手势识别</h3>

<p>     当上面的 _uiapplicationhandleeventqueue() 识别了一个手势时，其首先会调用 cancel 将当前的
touchesbegin/move/end 系列回调打断。随后系统将对应的 uigesturerecognizer 标记为待处理。</p>

<p>     苹果注册了一个 observer 监测 beforewaiting (loop即将进入休眠) 事件，这个observer的回调函数是
_uigesturerecognizerupdateobserver()，其内部会获取所有刚被标记为待处理的
gesturerecognizer，并执行gesturerecognizer的回调。</p>

<p>    当有 uigesturerecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>

<h3 id="界面更新">界面更新</h3>

<p>     当在操作 ui 时，比如改变了 frame、更新了 uiview/calayer 的层次时，或者手动调用了 uiview/calayer 的
setneedslayout/setneedsdisplay方法后，这个 uiview/calayer 就被标记为待处理，并被提交到一个全局的容器去。</p>

<p>     苹果注册了一个 observer 监听 beforewaiting(即将进入休眠) 和 exit (即将退出loop)
事件，回调去执行一个很长的函数：<br />
_zn2ca11transaction17observer_callbackep19__cfrunloopobservermpv()。这个函数里会遍历所有待处理的
uiview/calayer 以执行实际的绘制和调整，并更新 ui 界面。</p>

<p>     这个函数内部的调用栈大概是这样的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>_zn2ca11transaction17observer_callbackep19__cfrunloopobservermpv()
    quartzcore:ca::transaction::observer_callback:
        ca::transaction::commit();
            ca::context::commit_transaction();
                ca::layer::layout_and_display_if_needed();
                    ca::layer::layout_if_needed();
                        [calayer layoutsublayers];
                            [uiview layoutsubviews];
                    ca::layer::display_if_needed();
                        [calayer display];
                            [uiview drawrect];
</code></pre>
</div>

<h3 id="网络请求">网络请求</h3>

<p>     ios 中，关于网络请求的接口自下至上有如下几层:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cfsocket
cfnetwork       -&gt;asihttprequest
nsurlconnection -&gt;afnetworking
nsurlsession    -&gt;afnetworking2, alamofire
</code></pre>
</div>

<p>• cfsocket 是最底层的接口，只负责 socket 通信。<br />
• cfnetwork 是基于 cfsocket 等接口的上层封装，asihttprequest 工作于这一层。<br />
• nsurlconnection 是基于 cfnetwork 的更高层的封装，提供面向对象的接口，afnetworking 工作于这一层。<br />
• nsurlsession 是 ios7 中新增的接口，表面上是和 nsurlconnection 并列的，但底层仍然用到了
nsurlconnection 的部分功能 (比如 com.apple.nsurlconnectionloader 线程)，afnetworking2 和
alamofire 工作于这一层。</p>

<p>     通常使用 nsurlconnection 时，你会传入一个 delegate，当调用了 [connection start] 后，这个
delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 currentrunloop，然后在其中的 defaultmode
添加了4个 source0 (即需要手动触发的source)。cfmultiplexersource 是负责各种 delegate
回调的，cfhttpcookiestorage 是处理各种 cookie 的。</p>

<p>     当开始网络传输时，我们可以看到 nsurlconnection 创建了两个新线程：com.apple.nsurlconnectionloader
和 com.apple.cfsocket.private。其中 cfsocket 线程是处理底层 socket
连接的。nsurlconnectionloader 这个线程内部会使用 runloop 来接收底层 socket 的事件，并通过之前添加的 source0
通知到上层的 delegate。</p>

<p><img src="/image/yi_ge_chuang_jian_zi_ding_yi_shi_jian_yuan_de_li_zi/31b90899e7a07d66751bfacd23d3f4f1a56a54f394ecaa6e17eb4bc1e1fd178f" alt="" /></p>

<p>     nsurlconnectionloader 中的 runloop 通过一些基于 mach port 的 source 接收来自底层
cfsocket 的通知。当收到通知后，其会在合适的时机向 cfmultiplexersource 等 source0 发送通知，同时唤醒 delegate
线程的 runloop 来让其处理这些通知。cfmultiplexersource 会在 delegate 线程的 runloop 对 delegate
执行实际的回调。</p>

<h2 id="一个demo">一个demo</h2>

<p>          根据上面对nsurlconnection的介绍，我们模拟一个类似的设计来实现通过runloop来等待和处理事件。</p>

<h3 id="第一步创建任务线程">第一步：创建任务线程</h3>

<p>          创建子线程，用于初始化一个接收自定义事件源。该子线程主函数入口设计如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)main
{
    @autoreleasepool {
        nsrunloop *currentrunloop = [nsrunloop currentrunloop];
        //自定义的输入事件源source1，可以通过delegate回调，出发子线程处理方法
        self.custominputsource = [[custominputsource alloc] init];
        self.custominputsource.delegate = self;
        [self.custominputsource addtocurrentrunloop];
        while (!self.cancelled) {
            //runloop结束前完成其他任务
            [self finishothertask];
            [currentrunloop runmode:nsdefaultrunloopmode beforedate:[nsdate distantfuture]];
        }
    }
}
</code></pre>
</div>

<p> 主函数初始化自定义的事件源，通过delegate的方式回调回来。并将事件源加入到当前的runloop中。</p>

<h3 id="第二步设计自定义事件源">第二步：设计自定义事件源</h3>

<p>       自定义事件源包括初始化，添加事件源到指定runloop，从指定runloop中删除事件源等方法。而初始化方法中包含了run loop
source context的三个回调方法，具体代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (instancetype)init
{
    self = [super init];
    if (self) {
        /*runloopsourcecontext的三个回调方法:
         runloopsourcescheduleroutine():把当前的run loop source添加到run loop中时，会回调这个方法。  
         假如主线程管理该input source，可以使用performselectoronmainthread通知主线程。主线程和当前线程的通信使用ccrunloopcontext对象来完成。
         runloopsourceperformroutine():当前input source被告知需要处理事件.
         runloopsourcecancelroutine():如果使用cfrunloopsourceinvalidate函数把输入源从run loop里面移除的话,系统会回调该方法。  
         我们在该方法中移除了主线程对当前input source context的引用。
         */
        cfrunloopsourcecontext context = {0, (__bridge void *)(self), null, null, null, null, null,
            &amp;runloopsourcescheduleroutine,
            &amp;runloopsourcecancelroutine,
            &amp;runloopsourceperformroutine};
        _runloopsource = cfrunloopsourcecreate(kcfallocatordefault, 0, &amp;context);
    }
    return self;
}

- (void)addtocurrentrunloop
{
    cfrunloopref runloop = cfrunloopgetcurrent();
    cfrunloopaddsource(runloop, _runloopsource, kcfrunloopdefaultmode);
}

- (void)invalidate
{
    cfrunloopref runloop = cfrunloopgetcurrent();
    cfrunloopremovesource(runloop, _runloopsource, kcfrunloopdefaultmode);
} 
</code></pre>
</div>

<p>        注意：通过上述代码可以看出，自定义的事件源的实例是触发子线程工作的钥匙，所以这个实例对象，需要被与子线程相关联的线程所hold住。</p>

<p>       而触发自定义事件源的方法如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)fireallcommandsonrunloop:(cfrunloopref)runloop
{
    cfrunloopsourcesignal(_runloopsource);
    cfrunloopwakeup(runloop);
}
</code></pre>
</div>

<h3 id="第三步设计触发事件源的函数">第三步：设计触发事件源的函数</h3>

<p>        这一步顾名思义，在其他数据准备好的时候，通过自定义事件源触发子线程的工作。</p>

<h3 id="第四步退出子线程runloop">第四步：退出子线程runloop</h3>

<p>        退出runloop的方式也很简单，只需要将当前子线程的runloop实例停止就可以了，代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)stopthreadandrunloop:(cfrunloopref)runloop
{
    cfrunloopstop(runloop);
    [_custominputsourcethread cancel];
}
</code></pre>
</div>

<p>经过上面四个步骤，你就已经设计了一个属于你自己的自定义事件源，这个事件会根据你数据的准备情况来主动唤醒子线程的runloop来处理具体事件，这样的好处不言而喻，充分利用了runloop的特性，非常适合类似网络请求这样的异步等待事件。</p>


        </article>
        <hr>

        
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
        

        <div class="post-recent">
    <div class="pre">
        
        <p><strong>上一篇</strong> <a href="/2017/05/31/ios_shang_zhi_bo_dan_mu_de_yi_zhong_shi_xian/">ios上直播弹幕的一种实现</a></p>
        
    </div>
    <div class="nex">

        
        <p><strong>下一篇</strong> <a href="/2017/06/01/ios_shi_jian_ti_xi_zhi_shi_ji_yuan_li_xiao_ji/">ios 事件体系知识及原理小记</a></p>
        
    </div>
</div>


        <h2 id="comments">说一说</h2>
        

<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript">
var uyan_config = {
     'url':'http://localhost:4000/2017/06/01/yi_ge_chuang_jian_zi_ding_yi_shi_jian_yuan_de_li_zi/',
     'du':'http://localhost:4000', 
     'su':'http://localhost:4000/2017/06/01/yi_ge_chuang_jian_zi_ding_yi_shi_jian_yuan_de_li_zi/' 
};
</script>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2136610"></script>
<!-- UY END -->






    </div>
    <button class="anchor"><i class="fa fa-anchor"></i></button>
    <div class="right">
        <div class="wrap">

            <!-- Content -->
            <div class="side content">
                <div>
                    目录
                </div>
                <ul id="content-side" class="content-ul">
                    
                    <li><a href="#comments">说一说</a></li>
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <!-- <div class="side">bbbb</div> -->
        </div>
    </div>
</div>
<script>
/**
 * target _blank
 */
(function() {
    var aTags = document.querySelectorAll('article a:not([id])')
    for (var i = 0; i < aTags.length; i++) {
        aTags[i].setAttribute('target', '_blank')
    }
}());
</script>
<script src="/js/pageContent.js " charset="utf-8"></script>


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
            
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/MelonTeam" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>         
            
        </p>
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>


<script type="text/javascript" src="http://tajs.qq.com/stats?sId=62569168" charset="UTF-8"></script>


    <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/smooth-scroll.min.js " charset="utf-8"></script>
    <script type="text/javascript">
      smoothScroll.init({
        speed: 500, // Integer. How fast to complete the scroll in milliseconds
        easing: 'easeInOutCubic', // Easing pattern to use
        offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
      });
    </script>
    <!-- <script src=" /js/scroll.min.js " charset="utf-8"></script> -->
  </body>

</html>
