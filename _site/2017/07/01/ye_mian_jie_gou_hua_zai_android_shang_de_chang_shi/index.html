<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>页面结构化在Android上的尝试</title>
    <meta name="description" content="| 导语MVP开发模式可以帮助项目结构解耦，但其庞大的方法数增加，较为笨重设计对于手Q项目并不很适合。参考之前Web开发经验，提出以页面结构化的解耦方式组织代码。下面讲讲Lego在Android上一次小小尝试一，MVP简介">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_8v3czwksspqlg14i.css">
    <link rel="stylesheet" href="/css/main.css ">
    <link rel="canonical" href="http://localhost:4000/2017/07/01/ye_mian_jie_gou_hua_zai_android_shang_de_chang_shi/">
    <link rel="alternate" type="application/rss+xml" title="MelonTeam" href="http://localhost:4000/feed.xml ">



</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">MelonTeam</a>
        <small>移动终端前沿技术的探索者</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>首页
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/project/">
                        
                            <i class="fa fa-folder-open"></i>开源项目
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/class/">
                        
                            <i class="fa fa-book"></i>公开课
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>分类
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/board/">
                        
                            <i class="fa fa-pencil"></i>留言板
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" post>
    <div class="left">
        <h1>页面结构化在Android上的尝试</h1>
        <div class="label">

            <div class="label-card">
                <i class="fa fa-calendar"></i>2017-07-01
            </div>
            
            <div class="label-card">
                <i class="fa fa-user"></i>bizaitan
            </div>
            
            
            
            <div class="label-card">
            




<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#android" title="Category: android" rel="category">android</a>
    
  

  <!-- <span class="point">•</span> -->
</span>



            </div>
            
            
            <div class="label-card">
            


<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <!--a href="/tag/#LEGO" title="Tag: LEGO" rel="tag">LEGO</a-->
        <a href="/tag/#LEGO" title="Tag: LEGO" rel="tag">LEGO</a>&nbsp;
    
        <!--a href="/tag/#%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84..." title="Tag: 页面结构..." rel="tag">页面结构...</a-->
        <a href="/tag/#页面结构..." title="Tag: 页面结构..." rel="tag">页面结构...</a>
    
  

</span>



            </div>
            

        </div>
        <hr>
        <article itemscope itemtype="http://schema.org/BlogPosting">
        
<p>| 导语
MVP开发模式可以帮助项目结构解耦，但其庞大的方法数增加，较为笨重设计对于手Q项目并不很适合。参考之前Web开发经验，提出以页面结构化的解耦方式组织代码。下面讲讲Lego在Android上一次小小尝试</p>

<p><strong>一，MVP简介</strong></p>

<!--more-->
<p><strong><img src="/image/ye_mian_jie_gou_hua_zai_Android_shang_de_chang_shi/d8b32fbd6fe4df60eab0f0a9c483c207cd9f0c32f2c89197af5529da6c3ca0d5" alt="" /></strong></p>

<p>MVC太过常见这里不啰嗦。实际应用MVC当中，Activity占据打部分的工作，View和Controller的身份分不清。而MVP则是一种设计模式专门优化Activity
/ Fragment。</p>

<p>先来看看MVP模式的核心思想：<strong>View不直接与Model交互</strong></p>

<p>MVP 把 Activity 中的 UI 逻辑抽象成 View 接口，把业务逻辑抽象成 Presenter 接口，Model 类还是原来的 Model</p>

<p>在MVP设计模式中，</p>

<p><strong>View</strong>：由Activity充当，并且响应生命周期</p>

<p><strong>Model</strong>：还是原来的数据层，网络，缓存，解析等。</p>

<p><strong>Presenter</strong>：作为View和Model的中间纽带，View不能直接对Model进行操作，必须经过Presenter</p>

<p><strong>View interface</strong>：需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合</p>

<p>二，日迹MVP实战应用</p>

<p>【Mode层】我们直接忽略</p>

<p>【View
Interface】首页的View接口，抽离出view和presnter交互的接口。由Activity继承实现（Now.java，QQStoryMainActivity.java）</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public interface IMyStoryListView {
    public void setData(MyStorys myStoryList, RecentStory recentStoryList);
    public void setSegmentData(String key, Object data,boolean needRefreshUi);
    /**
     * 更新数据后刷新界面走的回调
     * @param success
     * @param isManualPullRefresh
     */
    public void pullRefreshCompleted(boolean success,boolean isReqCompleted);
    public void launchNewVideoTakeActivity(boolean autoStart, boolean checkSo, int entranceType,String extra);
    public void setPlayVideoBtnDisplay(boolean display);
    public void showStartDownload();
    public void showDownloadCompleted(boolean success);
    public void storyPreLoadCompleted(String category, String uin);
    public void LoadMoreCompleted(boolean repositoryUpdated, boolean isEnd);
    public void showEmptyView(boolean display);
    public void requestDataCompleted();
    public void openMyStoryListView(boolean open);
}
</code></pre>
</div>

<p>【View】我们的Activity实现了View接口，并且实现生命周期</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class QQStoryMainAcitivty extends QQStoryBaseActivity implements IMyStoryListView {

    protected StoryHomePushYellowBarHandler mStoryHomePushYellowBarHandler = new StoryHomePushYellowBarHandler();
    protected MystoryListView mainListView;
    protected IMyStroyPresenter myStoryListPresenter;

    @Override
    protected boolean doOnCreate(Bundle savedInstanceState) {
        super.doOnCreate(savedInstanceState);
        mainListView = (MystoryListView) super.findViewById(R.id.qqstory_story_main_listview);
        //Presenter
        myStoryListPresenter = new StoryListPresenter(this);
        myStoryListPresenter.setIView(this);
        return true;
    }

    @Override
    public void onStartAutoRequestFromNet() {
        startTitleProgress();
        mainListView.pullToRefresh();
        mStoryHomePushYellowBarHandler.clearYellowBar();
        myStoryListPresenter.requestAllDataFromNet();
    }

    private void startTitleProgress(){
        // do more
    }
}
</code></pre>
</div>

<p>举个例子，用户下拉刷新一下。触发到Activity的onStartAutoRequestFromeNet。View逻辑在Activity。</p>

<p>业务逻辑则由Presnter的requestAllDataFromNet去实现。</p>

<p>【Presenter】具体的View-&gt;Model,Mode-&gt;View由这里实现，其中View是有View接口抽象，进一步规范化View的逻辑。</p>

<p>必要是可以抽出Presenter接口（其实日迹这里没有必要）</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class StoryListPresnter implements IMyStroyPresenter{
    protected IMyStoryListView mIView;
    protected FeedItem mFeedItem;
    protected ParallelStepExecutor mRequestNetDataExecutor;

    @Override
    public void onCreate(boolean needUpdateFromNet) {
        // 生命周期的逻辑处理
        mFeedItem = new FeedItem();
    }
    @Override
    public void setIView(IMyStoryListView IView) {
        // 设置View接口(目前实现的是Activity，但其实由其他Fragment，View实现都是可以的，这就是MVP的好处之一，解耦)
        mIView = IView;
    }

    public boolean requestAllDataFromNet() {
        mRequestNetDataExecutor.addStep(new GetUserSelfInfoStep(null))
                .addStep(new ReportWatchVideoListStep(StoryListPresenter.this))
                .addStep(new GetUserGuideInfoStep(StoryListPresenter.this))
                .onCompleted(new SimpleStepExector.CompletedHandler() {
                    @Override
                    public void done(FeedItem item) {
                        // 伪代码
                        mFeedItem = item;                       // 处理Model层
                        mIView.openMyStoryListView(mFeedItem);  // 根据View接口调用View更新
                    }
                }).run();
    }

}
</code></pre>
</div>

<p>MVP的优缺点：</p>

<p>优点：</p>

<p>1. 解耦，绝对的。不然抽这么多接口干嘛</p>

<p>2. 模块职责明确，层次清晰</p>

<p>3. Presenter可复用（在日迹的需求中，首页和4Tab公用一个Presnter）</p>

<p>4. 方便单元测试</p>

<p>5. 避免Activity内存泄露， Acitvity一身轻松</p>

<p>MVP的缺点也是非常明确的</p>

<p>1. 非常的笨重。一个View就对应一个Presenter，轻业务一个Activity能解决的就不要解决</p>

<p>2. Presnter依然逻辑繁重。Acitivty轻松了，业务逻辑庞大的时候Presnter依然是大胖子。</p>

<p>3. 代码复杂度，学习成本。这玩意不好理解，需要实战中理解。</p>

<p>4. 在手Q项目里，MVP会激增很多方法数，</p>

<p><img src="/image/ye_mian_jie_gou_hua_zai_Android_shang_de_chang_shi/c7712fbf9c37de4ed1d2b697d12dbcce00b329c7dfaf1c7c86b197e60f37c7fa" alt="" /></p>

<p>三，Lego页面结构化</p>

<p><strong> </strong></p>

<p>前面铺垫这么多，终于到我要吹水的时候了。MVC，MVP，还有MVVM等MVX系列的设计模式，都是一种大而全的统一管理。在项目结构中最为关键其实是：分模块！</p>

<p><img src="/image/ye_mian_jie_gou_hua_zai_Android_shang_de_chang_shi/33a461966937ac209e4478fedf4506c21f5a889c4464a54d4ab01b817f7c3f4a" alt="" /></p>

<p>看看某宝的首页，顶部搜索栏，banner，导航分类，抢购，特价，底部Tab。这是一个Activity的话，你再怎么MVP，也是需要划分模块，然后分而治之。</p>

<p>一个再大的系统，都可以划分一个个小的模块，分而治之</p>

<p>页面结构化，并不是新玩意，是当时做web的一套代码风格。下图是当时做Web总结组件化的一张图。现在看来，也就并没有过时</p>

<p><img src="/image/ye_mian_jie_gou_hua_zai_Android_shang_de_chang_shi/fa1f198b6ca44df1b81968f2c20928e7b1aced3457b77dc973202d4ec4da29e6" alt="" /></p>

<p>页面被划分问一个个区域的模块，有自身的逻辑和规划。有人说，这不就是一个个组件嘛。然后“页面结构化”并不是指组件。</p>

<p>例如上图的tabContainer，imgsContainer，listContainer，每一个模块都有自己的渲染模板（xml），请求的数据的CGI（数据源），自身的事件绑定（listener）
，状态机（生命周期），并不只是一个组件，而是一个个有自己生命力，能自己管理的小页面。</p>

<p><strong>根据页面结构，划分出一个个独立维护模块，这就是页面结构化。</strong></p>

<p><strong>##  页面结构化（Lego）与组件化的区别</strong></p>

<p>1. 组件处于通用性，是不带业务逻辑的。而页面结构化是带业务逻辑。</p>

<p>2. 页面结构化目的是为了代码维护性，项目管理，优化。组件复用可以有，但不是必要</p>

<p>3. 组件与Lego不冲突。组件 +数据，业务逻辑 = Lego</p>

<p>下面就以问答的形式，用日迹评论赞项目实战，来讲解Lego好处</p>

<p>四，分析页面结构化特性</p>

<p><strong>##  Lego自己拉取自己的数据，如果一个页面5,6个模块，就拉5,6分PB协议，谈何性能？</strong></p>

<p>这里带出Lego两个特性：</p>

<p>1. 每个Lego是有自己的数据，并不是一定要自己拉取，数据可以有其他Lego传递</p>

<p>2. Lego有父子关系。一个页面/Activity需要一个顶层Lego管理</p>

<p>日迹首页评论赞</p>

<p><img src="/image/ye_mian_jie_gou_hua_zai_Android_shang_de_chang_shi/6c6ab3ada2ff3727941c4a7deaf4b931c2a2cfa102e64d5a191deb9ecf42261f" alt="" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>public FeedCommentLikeLego(Context context, Activity activity, ViewGroup parentView, HomeFeedItem feedItem, int feedType) {
    super(context, parentView);
    mHomeFeedItem = feedItem;
    mFeedItem = feedItem.mFeedBasicItem;
    mActivity = activity;
    mFeedType = feedType;
    mLikeManager = (LikeManager) SuperManager.getAppManager(SuperManager.LIKE_MANAGER);
    mParentView = LayoutInflater.from(context).inflate(R.layout.qqstory_feed_commentlike_view, parentView, true);

    // 页面结构
    FeedCommentLego commentLego = new FeedCommentLego(mContext, mParentView, mFeedItem, mFeedType);
    FeedLikeLego likeLego = FeedLikeLego.createIndexFeedLikeLego(mContext, activity, mParentView, mFeedItem, mFeedType);
    addLego(LEGO_KEY_COMMENT, commentLego);
    addLego(LEGO_KEY_LIKE, likeLego);
    commentLego.feed(mHomeFeedItem.getCommentList());
    likeLego.feed(mHomeFeedItem.getLikeEntryList());
    boot();
}
</code></pre>
</div>

<p> 从FeedCommentLikeLego的构造方法，我们得知</p>

<p>1. 我是爸爸，我有两个儿子</p>

<p>2. 我两个儿子不争气，需要我来喂养数据，自己不会挣钱（自己不拉数据）</p>

<p>3. 全家我是一家之主，启动我说了算（Lego启动boot后，会自己拉数据自己渲染，同时子Lego也会相继boot）</p>

<p>日迹710这里就有场景，体验出Lego切换数据源的优势。</p>

<p>【首页】出于性能优化，都会做请求合并。返回多个Feed的视频列表，评论赞列表数据。</p>

<div class="highlighter-rouge"><pre class="highlight"><code> commentLego.feed(mHomeFeedItem.getCommentList());  
 likeLego.feed(mHomeFeedItem.getLikeEntryList());
</code></pre>
</div>

<p>被喂养数据后，Lego内部的DataProvider将不启动</p>

<p>【详情页】同一Lego，默认情况就会启动资金的DataProvider，会自己拉数据</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override  
public LegoDataProvider getDataProvider() {  
    return new FeedLikeDataProvider(this, mIsDetailPage);  
}
</code></pre>
</div>

<p><strong>## 一个Lego类是究竟是什么？Lego类之间的纽带？</strong></p>

<p>大部分页面的渲染流程线，如下图</p>

<p><img src="/image/ye_mian_jie_gou_hua_zai_Android_shang_de_chang_shi/bec1f8d682b167b63cc66af68ed6aeeabe8953f988245a96df99a0b63ae55dec" alt="" /></p>

<p>我们把这些常用的网络请求，处理数据，事件绑定，上报，容错处理等一系列逻辑方法，以页面块为单位封装成一个Lego模块。</p>

<p>这样的一个抽象层Lego，我们可以清晰地看到该页面块，请求的数据是什么，绑定了什么事件，做了什么上报，出错怎么处理。</p>

<p>最后加上生命周期，页面结构化的Lego，已经算是一个完整的功能单元了。</p>

<p>继承LegoBase，有几个核心的方法需要重写：</p>

<table>
  <thead>
    <tr>
      <th>getEvenHandler() </th>
      <th>事件绑定器，一切需要setOnXXXLisnter都丢给他</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>getDataProvider()</td>
      <td>数据拉取器，里面还有一套LegoRequestBase的网络封装，最大成本简化网络请求和回包处理</td>
    </tr>
    <tr>
      <td>initView() </td>
      <td>View的初始化，只会执行一次</td>
    </tr>
    <tr>
      <td>render() </td>
      <td>这个Lego的唯一渲染接口</td>
    </tr>
    <tr>
      <td>showLoding() </td>
      <td>状态机之一，可以展示Loading菊花，可以DB获取缓存先渲染缓存</td>
    </tr>
    <tr>
      <td>showSuccess() </td>
      <td>状态机之一，success</td>
    </tr>
    <tr>
      <td>showError()    </td>
      <td>状态机之一，error</td>
    </tr>
  </tbody>
</table>

<p>还有生命周期方法可以重写，但不是必要的。</p>

<p>你阅读/接手一个Lego类，会是件很轻松的事情。一个Lego类，核心方法这几个，其余都是业务逻辑方法。</p>

<p>改事件去该Lego的EventHandler，数据要改去DataProvider，产品要求大V才展示底部尾巴，好，去render方法找。</p>

<p>Lego之间的纽带，有三个：</p>

<p>parentView（公用xml）</p>

<p>feedData（公用数据）</p>

<p>getLego（Lego关系）</p>

<p>四，总结</p>

<p>Lego的核心思想是：页面结构分模块，分而治之。解耦，代码可读性高，底层统一优化</p>

<p>在使用了两个版本之后，感觉完成度还是不够。</p>

<p>1. 顶层Lego情况复杂，底层统一优化不好做</p>

<p>2. 接口之间约束，不够自由</p>

<p>但是对比MVP，Lego能体验出轻便，逻辑清晰，方法数量少的优势。</p>

<p>Lego页面结构化的应用其实还在尝试阶段。以上算我的一些个人思考和总结。</p>


        </article>
        <hr>

        
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
        

        <div class="post-recent">
    <div class="pre">
        
        <p><strong>上一篇</strong> <a href="/2017/07/01/_yi_android_instant_apps_jian_jie/">[译]Android Instant Apps简介</a></p>
        
    </div>
    <div class="nex">

        
        <p><strong>下一篇</strong> <a href="/2017/07/01/fork_join_kuang_jia/">Fork/Join 框架</a></p>
        
    </div>
</div>


        <h2 id="comments">说一说</h2>
        

<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript">
var uyan_config = {
     'url':'http://localhost:4000/2017/07/01/ye_mian_jie_gou_hua_zai_android_shang_de_chang_shi/',
     'du':'http://localhost:4000', 
     'su':'http://localhost:4000/2017/07/01/ye_mian_jie_gou_hua_zai_android_shang_de_chang_shi/' 
};
</script>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2136610"></script>
<!-- UY END -->






    </div>
    <button class="anchor"><i class="fa fa-anchor"></i></button>
    <div class="right">
        <div class="wrap">

            <!-- Content -->
            <div class="side content">
                <div>
                    目录
                </div>
                <ul id="content-side" class="content-ul">
                    
                    <li><a href="#comments">说一说</a></li>
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <!-- <div class="side">bbbb</div> -->
        </div>
    </div>
</div>
<script>
/**
 * target _blank
 */
(function() {
    var aTags = document.querySelectorAll('article a:not([id])')
    for (var i = 0; i < aTags.length; i++) {
        aTags[i].setAttribute('target', '_blank')
    }
}());
</script>
<script src="/js/pageContent.js " charset="utf-8"></script>


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
            
        </p>
        <p class="power">
            <span>
                Copyright © 2017 <a href="https://github.com/MelonTeam" title="GitHub">MelonTeam <i class="fa fa-github" aria-hidden="true"></i></a>. All Rights Reserved.
            </span>
        </p>
    </div>
</footer>


<script type="text/javascript" src="http://tajs.qq.com/stats?sId=62569168" charset="UTF-8"></script>


    <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/smooth-scroll.min.js " charset="utf-8"></script>
    <script type="text/javascript">
      smoothScroll.init({
        speed: 500, // Integer. How fast to complete the scroll in milliseconds
        easing: 'easeInOutCubic', // Easing pattern to use
        offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
      });
    </script>
    <!-- <script src=" /js/scroll.min.js " charset="utf-8"></script> -->
  </body>

</html>
